using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace HowProgrammingWorksOnDotNet.Generators;

[AttributeUsage(AttributeTargets.Enum, AllowMultiple = false, Inherited = false)]
public class SmartEnumAttribute : Attribute
{
    public string? Name { get; set; }
}

[Generator]
public class SmartEnumGenerator : IIncrementalGenerator
{
    private static bool Predicate(SyntaxNode node, CancellationToken token) =>
        node is EnumDeclarationSyntax;

    private static (INamedTypeSymbol, AttributeData)? Transform(
        GeneratorSyntaxContext context,
        CancellationToken token
    )
    {
        var enumSyntax = (EnumDeclarationSyntax)context.Node;
        var enumSymbol = (INamedTypeSymbol)context.SemanticModel.GetDeclaredSymbol(enumSyntax)!;

        var smartEnumAttribute = enumSymbol
            .GetAttributes()
            .FirstOrDefault(ad => ad.AttributeClass?.Name == nameof(SmartEnumAttribute));

        return smartEnumAttribute != null ? (enumSymbol, smartEnumAttribute) : null;
    }

    private static string GenerateSource(INamedTypeSymbol enumSymbol, string entityName)
    {
        string namespaceName = $"{enumSymbol.ContainingNamespace}";

        var fields = enumSymbol
            .GetMembers()
            .OfType<IFieldSymbol>()
            .Where(f => f.ConstantValue is int);

        var memberNames = fields.Select(f => f.Name);

        var memberFields = fields.Select(f =>
            $"    public static readonly {entityName} {f.Name} = new({f.ConstantValue}, \"{f.Name}\");"
        );

        string source = $$"""
            // <auto-generated/>
            namespace {{namespaceName}};

            public record {{entityName}} {
                public int Code { get; }
                public string Name { get; }

            {{string.Join("\n", memberFields)}}

                public static List<{{entityName}}> All => [{{string.Join(", ", memberNames)}}];

                private {{entityName}}(int code, string name)
                {
                    Code = code;
                    Name = name;
                }

                private static {{entityName}} GetOrThrow(Func<{{entityName}}, bool> predicate) =>
                    All.FirstOrDefault(predicate) ?? throw new InvalidOperationException();

                public static {{entityName}} From(string name) => GetOrThrow(e => e.Name == name);

                public static {{entityName}} From(int code) => GetOrThrow(e => e.Code == code);
            }
            """;

        return source;
    }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var enums = context
            .SyntaxProvider.CreateSyntaxProvider(predicate: Predicate, transform: Transform)
            .Where(item => item != null);

        context.RegisterSourceOutput(
            enums,
            (context, item) =>
            {
                if (item == null)
                    return;

                (var enumSymbol, var attr) = item.Value;

                string? nameFromAttribute = attr
                    .NamedArguments.FirstOrDefault(arg =>
                        arg.Key == nameof(SmartEnumAttribute.Name)
                    )
                    .Value.Value?.ToString();

                string entityName = nameFromAttribute ?? $"{enumSymbol.Name}SmartEnum";

                string source = GenerateSource(enumSymbol, entityName);
                context.AddSource($"{entityName}.g.cs", source);
            }
        );
    }
}
